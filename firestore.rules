rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ARCHITECTURE PRINCIPLE: Firestore is the source of truth.
    // These rules enforce the data model defined in backend.json.

    // ----------------
    // Helper Functions
    // ----------------
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      // ARCHITECTURE PRINCIPLE: Critical logic runs in backend. Admin status is managed by backend.
      // This function securely checks for admin privileges without exposing admin list.
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    function isNewData(data) {
      return resource == null;
    }
    
    function existingData() {
      return resource.data;
    }
    
    function incomingData() {
      return request.resource.data;
    }

    // ----------------
    // Collection Rules
    // ----------------
    
    // User Profiles
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();

      // A user can create their own profile. An admin can create any.
      allow create: if isOwner(userId) || isAdmin();
      
      // ARCHITECTURE PRINCIPLE: Clients never modify sensitive data.
      // The 'role' field can only be changed by an admin.
      allow update: if (isOwner(userId) && incomingData().role == existingData().role) || isAdmin();
      
      allow delete: if isAdmin(); // Only admins can delete user profiles.
    }
    
    // Services offered by a provider
    match /users/{userId}/services/{serviceId} {
        allow get, list: if true; // All services are public to view.
        
        // Only the provider can create/update/delete their own services.
        allow create, update, delete: if isOwner(userId);
    }

    // Provider public profiles
    match /providers/{providerId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin() || isOwner(providerId);
    }
    
    // Provider Availability
    match /providers/{providerId}/availability/{docId} {
       allow get: if isOwner(providerId) || isAdmin();
       allow list: if isOwner(providerId) || isAdmin();
       allow create, update: if isOwner(providerId);
       allow delete: if false; // Should be updated, not deleted.
    }

    // Bookings
    match /bookings/{bookingId} {
      // A customer or provider can get a booking they are involved in.
      allow get: if isSignedIn() && (isOwner(existingData().customerId) || isOwner(existingData().providerId));
      
      // Users can only list their own bookings, not all of them.
      // This requires queries on the client side (e.g., where('customerId', '==', auth.uid))
      allow list: if isSignedIn();
      
      // A customer can create their own booking.
      allow create: if isOwner(incomingData().customerId);
      
      // A customer can cancel a pending/confirmed booking.
      // A provider can confirm a pending booking or complete a confirmed one.
      allow update: if (isOwner(existingData().customerId) && incomingData().status == 'cancelled') || 
                       (isOwner(existingData().providerId) && (
                         (existingData().status == 'pending' && incomingData().status == 'confirmed') ||
                         (existingData().status == 'confirmed' && incomingData().status == 'completed')
                       ));

      // Bookings are archived (cancelled), not deleted by clients.
      allow delete: if false; 
    }
    
    // Admin role management collection
    match /roles_admin/{userId} {
      // This collection is managed by backend/admins only.
      // No client-side reads or writes are allowed for listing/writing.
      allow get: if isOwner(userId);
      allow list, write: if false;
    }
  }
}
