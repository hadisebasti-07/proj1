rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ARCHITECTURE PRINCIPLE: Firestore is the source of truth.
    // These rules enforce the data model defined in backend.json.

    // ----------------
    // Helper Functions
    // ----------------
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      // ARCHITECTURE PRINCIPLE: Critical logic runs in backend. Admin status is managed by backend.
      // This function securely checks for admin privileges without exposing admin list.
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    function isNewData(data) {
      return resource == null;
    }
    
    function existingData() {
      return resource.data;
    }
    
    function incomingData() {
      return request.resource.data;
    }

    // ----------------
    // Collection Rules
    // ----------------
    
    // User Profiles
    match /users/{userId} {
      // A user can read their own profile, or an admin can.
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();

      // A user can create their own profile. An admin can create any.
      allow create: if isOwner(userId) || isAdmin();
      
      // ARCHITECTURE PRINCIPLE: Clients never modify sensitive data.
      // The 'role' field can only be changed by an admin.
      allow update: if (isOwner(userId) && incomingData().role == existingData().role) || isAdmin();
      
      allow delete: if isAdmin(); // Only admins can delete user profiles.
    }
    
    // Services are now in a top-level collection for easier querying.
    match /services/{serviceId} {
        allow get, list: if true; // All services are public to view.
        
        // Only the provider who owns the service can manage it.
        // We check the providerId field on the service document.
        allow create, update, delete: if isOwner(incomingData().provider.id);
    }

    // Provider public profiles
    match /providers/{providerId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin() || isOwner(providerId);
    }
    
    // Provider Availability
    match /providers/{providerId}/availability/{docId} {
       allow get: if isOwner(providerId) || isAdmin();
       allow list: if isOwner(providerId) || isAdmin();
       allow create, update: if isOwner(providerId);
       allow delete: if false; // Should be updated, not deleted.
    }

    // Bookings
    match /bookings/{bookingId} {
      // A customer or provider can get a booking they are involved in.
      allow get: if isSignedIn() && (isOwner(existingData().customerId) || isOwner(existingData().providerId));
      
      // IMPORTANT SECURITY FIX: Removed insecure `list` rule.
      // Clients must query bookings with a 'where' clause (e.g., where('customerId', '==', auth.uid))
      // which is implicitly allowed if the 'get' rule passes for each document in the result.
      allow list: if false;
      
      // A customer can create their own booking.
      allow create: if isOwner(incomingData().customerId);
      
      // A customer can cancel a pending/confirmed booking.
      // A provider can confirm a pending booking or complete a confirmed one.
      allow update: if (isOwner(existingData().customerId) && incomingData().status == 'cancelled') || 
                       (isOwner(existingData().providerId) && (
                         (existingData().status == 'pending' && incomingData().status == 'confirmed') ||
                         (existingData().status == 'confirmed' && incomingData().status == 'completed')
                       ));

      // Bookings are archived (cancelled), not deleted by clients.
      allow delete: if false; 
    }
    
    // Admin role management collection
    match /roles_admin/{userId} {
      // This collection is managed by backend/admins only.
      // No client-side reads or writes are allowed for listing/writing.
      allow get: if isOwner(userId) || isAdmin();
      allow list, write: if false;
    }
  }
}
